<!--
  Copyright 2020 Joel FALCOU

  Licensed under the MIT License <http://opensource.org/licenses/MIT>.
  SPDX-License-Identifier: MIT
 -->
<meta charset="utf-8" lang="en"><style class="fallback">body{visibility:hidden;}</style>
                       **Joel Falcou, Ph. D**


  (insert ../../../../crumbs.html here)

# APP4 - C++ - TP 4 - 2H

Téléchargez le projet (number-variant.zip).

Comme pour les exercices précédents, la compilation s'effectue avec `cmake` en exécutant la commande `cmake .` dans le répertoire principal (contenant le fichier `CMakeLists.txt`). Comme précédemment,  une seule exécution de `cmake` est nécessaire, et il vous suffit ensuite d'appeler `make` dans le dossier. Et pareil, exécuter le binaire une fois compilé il faut exécuter `./number-variant`.

On a un programme dont la structure s’étale sur plusieurs fichiers.

Le fichier `types.hpp` contient les types de base, le header `printing.hpp`
contient les declarations des `operator<<` pour afficher les objets définis dans
une sortie standard, `arithmetic.hpp` qui contient les declarations des
opérateurs arithmétiques, et `number_factory.hpp` qui contient les declarations
relatives a la construction de ces objets a partir de chaines de caractères.

Les definitions (CaD les implementations) sont définies dans les fichiers
sources (ie. `.cpp`) correspondants. Les headers (ie. les `.hpp`) ne contiennent
que les *declarations* de fonction, CaD les prototypes sans les corps des
fonctions.

Vous aurez besoin de la doc de `std::variant`:
https://en.cppreference.com/w/cpp/utility/variant

**Attention:** Les lambdas que vous passez a `std::visit` doivent **toujours**
renvoyer le meme type.

1.  Dans `types.hpp`, définissez `number_t` qui permet de représenter soit un
    `int`, soit un `double`.

2.  Implementez un `operator<<` pour pouvoir afficher un `number_t` dans un
    `std::ostream`. Pour cela vous devrez surcharger l'`operator<<` avec la
    bonne signature, que vous trouverez dans `printing.hpp`.

3.  Implementez les operateurs arithmetiques entre `fraction_t` dans
    `arithmetic.cpp`, puis faites de meme pour `number_t`.
    Pour les operations sur des `fraction_t`, on ne demande pas que les
    fractions soient simplifiees.
    Pour les operations sur `number_t`, on se contente d'utiliser les operateurs
    arithmetiques des types contenus.

4.  Etendez `number_t` pour qu'il puisse egalement contenir un valeur de type
    `fraction_t` ou de type `std::complex<double>`.

5.  Implementez la fonction `number_factory` dans `number_factory.cpp`.
    Le premier parametre contient l'une des chaines de caracteres suivantes:
    "real", "complex", "integer", ou "fraction", et doit construire un
    `number_t` contenant une valeur du type defini a partir de la chaine de
    caracteres du 2e parametre.

    Dans le cas ou le premier parametre ne correspond a rien, renvoyez un
    `number_t` dont la valeur est celle par defaut.

    Utilisez `std::istringstream` pour la lecture des valeurs numeriques,
    les tests sont la pour lever les ambiguites sur les formats des differents
    types de valeurs.

6.  Faites des modifications a `arithmetic.cpp` et recompilez en observant quels
    fichiers sont recompiles. Quel est l'impact d'une modif de ce fichier ?
    Meme question pour `types.hpp`.

----------------------------------------------------------------------------------------------------
<!-- Shortcuts -->

<!-- Footnotes -->

<!-- End of Document -->
<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'none'};</script>
<link rel="stylesheet" href="../../../../style.css">
<!-- Markdeep: -->
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>

